# E-Commerce
### Tested with Flutter 3.19.5 and Dart 3.3.3

## Install Extensions (VS Code / Android Studio / Intellij)
- Flutter
- Dart
- Build Runner
- Flutter Riverpod Snippets (Optional)
- Freezed (Optional)

### run `flutter pub upgrade` and `flutter pub get`

### Optional
- [Install Spider for better assets control and create asset testings](https://github.com/BirjuVachhani/spider)

### API
[Platzi fake API](https://fakeapi.platzi.com/en/rest)

### run `flutter pub run build_runner build` (with `--delete-conflicting-outputs` if there are any conflict files)
    - `watch` to continuosly rebuild at each
    - `build` for manually
---
### Lib
- common
    - Common UI and interface components (assets classes, widgets and screens not part of a feature)
- features
    - each feature has its own subfolders in the format of:
        - application
            - UI components and Flutter widget related classes
            - screen
            - widget
            - controller (riverpod)
                - riverpod controller that connects to domain services (also providers) to get domain entities and VO to make reactive UI 
        - domain
            - exceptions
                - each domain has its own business rule and exception
            - implementation
                - implementation of services or repositories
            - model
                - domain entities and VO
                - immutable (anemic) domain
            - service
                - repositories and services use case (if any), this are interfaces that provide a way to get domain objects
        - infrastructure
            - data
                - external services to get information from
            - model
                - models used by the data source, this are not part of the domain because are just intermediate from the data source to a real domain entity (DTOs from HTTP, local DB, etc)
    - routing
        - route constant names
        - route provider retrieving a Route 2.0 router (Go Router)
    - shared
        - model
            - shared model across multiple features (not related to a single domain)
        - Riverpod providers that works as HTTP classes, I/O or external interfaces that can be used for many controllers or repositories
    - utils
        - classes, extensions, constants, validators, etc. all kind of code that provides certain functionality or logic without being part of a feature

---
- The app has 3 features:
    - Authentication
        - Login and SignUp
        - **Note**: to test signup read the [comment here](lib/features/authentication/domain/implementation/user_repository.dart)
    - Cart
        - save products and quantities
        - Persists locally
    - Product
        - list and detailed products

There are multiple providers across the features subfolders (and shared). The idea is to have this providers from the data source to the actual controller that will be used in the UI (infrastructure -> repository/service -> controller). With this logic in mind the providers will be created by Riverpod when used without having to figure out when to initialize it (nor initialize all repositories in main) cleaning the actual UI from boilerplate.

---
### [analysis_options.yaml](analysis_options.yaml)
- Ignore lint and modify dart analyzer (usually autogenerated)
---
### [build.yaml](build.yaml)
- Configuration for libraries that depends on build_runner (retrofit, json_serializable, Freezed and Riverpod generator)
---
### [spider.yaml](spider.yaml)
- Spider CLI configuration (name and route of files, allowed files per class, generate testings related to assets, etc)
---
The app doesn't need further configuration (no env files, firebase configuration, etc) so as long as Flutter is installed with Android SDK or Xcode and an Emulator/Simulator or real device is at hand everything is good to go (`flutter run` in CMD)